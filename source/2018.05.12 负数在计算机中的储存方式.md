最近在学习位运算符时，发现负数在做带符号位的右移运算符时，结果与想象中的大不一样，经过查阅资料之后发现，原来这一切源自负数在计算机中的储存方式<br>
负数在计算机中是以**补码**的形式储存的<br>
**注意：** 本文为了简化运算，二进制数都是用一个字节——8个二进制位说明
## 1 一些概念
在进行问题探究之前，先了解一些概念
### 1.1 原码
原码就是符号位加上真值的绝对值，即8位二进制数的第一位是符号位，其余位表示值
>+1(原) = 0000 0001<br>
>-1(原) = 1000 0001<br>

第一位表示正负号，所以8位二进制数的取值范围是
>[1111 1111 , 0111 1111]

即[-127,127]

### 1.2 反码
正负数的反码规则不一样<br>
正数的反码就是其本身<br>
负数的反码就是，在原码的基础上，符号位不变，其余位取反
>+1 = [0000 0001] (原) = [0000 0001] (反)<br>
>-1 = [1000 0001] (原) = [1111 1110] (反)

### 1.3 补码
补码的计算规则为<br>
正数的补码就是其本身<br>
负数的补码就是在其反码的基础上+1
>+1 = [0000 0001] (原) = [0000 0001] (反) = [0000 0001] (补)<br>
>-1 = [1000 0001] (原) = [1111 1110] (反) = [1111 1111] (补)
## 2 为何这么复杂
从上面我们可以知道，负数的原码、反码、补码是很不一样的，这样设计的好处是方便计算机做减法<br>
首先，因为人可以轻松知道第一位是符号位，在计算的时候我们会根据符号位，选择对真值区域的加减。但是要让计算机辨别"符号位"显然会让计算机的基础电路设计变得十分复杂！于是就想出了将符号位也参与运算的方法。我们知道，根据运算法则减去一个正数等于加上一个负数，即：1-1 = 1 + (-1) = 0 , 所以机器可以只有加法而没有减法, 这样计算机运算的设计就更简单了



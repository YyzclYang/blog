## 前言

在开始之前，还是看看上篇文章 AJAX 代码。
```JavaScript
button.addEventListener("click", e => {
  let request = new XMLHttpRequest();
  request.open("GET", "/yyzcl");
  request.setHeader("yyzcl","OK");
  request.send("Yyzcl");
  request.onreadystatechange = () => {
    if (request.readyState === 4) {
      let string = request.responseText;
      let obj = window.JSON.parse(string);
    }
  };
});
```
在这里，将这些代码封装一下，并增加成功失败判断调取对应的函数，然后去调用它。
```JavaScript
window.jQuery.ajax = function({ url, method, body, successFn, failFn, headers }) {
    let request = new XMLHttpRequest();
    request.open(method, url);
    for (let key in headers) {
      let value = headers[key];
      request.setRequestHeader(key, value);
    }
    request.onreadystatechange = () => {
      if (request.readyState === 4) {
        if (request.status >= 200 && request.status < 300) {
          successFn.call(undefined, request.responseText);
        } else if (request.status >= 400) {
          failFn.call(undefined, request);
        }
      }
    };
    request.send(body);
};

button.addEventListener("click", e => {
  window.jQuery
    .ajax({
      url: "/yyzcl",
      method: "get",
      body: "Yyzcl",
      successFn: (responseText) => {
        amount.innerText = amount.innerText - 1;
        return responseText;
      },
      failFn: (request) => {
        console.log("通讯失败");
        return request;
      }
    })
});
```
在使用`window.jQuery.ajax`的封装时，必须同时将成功失败函数一起传递进去，而且必须知道成功失败函数的名字（不同库的`ajax`的成功失败函数名有可能不一样），这就显得十分的麻烦，而`Promise`则很好地解决了这个问题。

## Promise

Promise 对象是 JavaScript 的异步操作解决方案，为异步操作提供统一接口。它起到代理作用（proxy），充当异步操作与回调函数之间的中介，使得异步操作具备同步操作的接口。Promise 可以让异步操作写起来，就像在写同步操作的流程，而不必一层层地嵌套回调函数。

## Promise 对象的状态

Promise 对象通过自身的状态，来控制异步操作。Promise 实例具有三种状态。

- 异步操作未完成（pending）
- 异步操作成功（fulfilled）
- 异步操作失败（rejected）

上面三种状态里面，`fulfilled`和`rejected`合在一起称为`resolved`（已定型）。

这三种的状态的变化途径只有两种。

- 从“未完成”到“成功”
- 从“未完成”到“失败”

一旦状态发生变化，就凝固了，不会再有新的状态变化。这也是 Promise 这个名字的由来，它的英语意思是“承诺”，一旦承诺成效，就不得再改变了。这也意味着，Promise 实例的状态变化只可能发生一次。

因此，Promise 的最终结果只有两种。

- 异步操作成功，Promise 实例传回一个值（value），状态变为`fulfilled`。
- 异步操作失败，Promise 实例抛出一个错误（error），状态变为`rejected`。

## Promise 构造函数

Promise 是一个对象，也是一个构造函数，下面看一个 Promise 例子。
```JavaScript
var promise = new Promise(function (resolve, reject) {
  // ...

  if (/* 异步操作成功 */){
    resolve(value);
  } else { /* 异步操作失败 */
    reject(error);
  }
});
```
`Promise`作为构造函数接受一个函数作为参数，这个函数接受两个函数（`resolve`和`reject`）作为参数。

在`Promise`异步操作成功时调用`resolve`函数，当异步操作失败时调用`reject`函数。

而`reslove`和`reject`函数可以用`then`传递进去。

## then

`then`方法可以接受两个回调函数，第一个是异步操作成功时（变为`fulfilled`状态）时的回调函数，第二个是异步操作失败（变为`rejected`）时的回调函数（该参数可以省略）。一旦状态改变，就调用相应的回调函数。

```JavaScript
var promise = new Promise(function (resolve, reject) {
  // ...

  if (/* 异步操作成功 */){
    resolve(value);
  } else { /* 异步操作失败 */
    reject(error);
  }
});

promise.then(
  (value) => {},
  (error) => {}
).then(
  (value) => {},
  (error) => {}
)
```
`then`支持链式操作，`then`之后可以继续接`then`，不过后面的`then`里面函数的参数时前面的`then`的运行结果。

## Promise 运行顺序
`promise`在新建之后会立即执行，而调用`promise`之后`then`方法的回调函数，将在当前脚本所有的同步任务全部完成之后才会执行.

```JavaScript
let promise = new Promise(function(resolve, reject) {
  console.log('Promise');
  resolve();
});

promise.then(function() {
  console.log('resolved.');
});

console.log('Hi!');

// Promise
// Hi!
// resolved
```

上面代码中，`promise`新建后立即执行，所以首先输出的是`Promise`。然后，`then`方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行，所以`resolved`最后输出。

## 重新封装 ajax

有了`Promise`之后，上面的`ajax`封装就可以这么写：
```JavaScript
window.jQuery.ajax = function({ url, method, body, headers }) {
    return new Promise (function (resolve, reject){
        let request = new XMLHttpRequest();
        request.open(method, url);
        for (let key in headers) {
          let value = headers[key];
          request.setRequestHeader(key, value);
        }
        request.onreadystatechange = () => {
          if (request.readyState === 4) {
            if (request.status >= 200 && request.status < 300) {
              successFn.call(undefined, request.responseText);
            } else if (request.status >= 400) {
              failFn.call(undefined, request);
            }
          }
        };
        request.send(body);
    })
};

button2.addEventListener("click", e => {
  window.jQuery
    .ajax({
      url: "/yyzcl",
      method: "get",
      body: "Yyzcl",
    })
    .then(
      (responseText) => {
        amount.innerText = amount.innerText - 0 + 1;
        return responseText;
      },
      (request) => {
        console.log("通讯失败");
        return request;
      });
});
```
从上面的代码可以知道，当我们调用封装好的`ajax`接口，并不需要知道成功失败函数的名字，直接利用`then`传递进去即可，使 AJAX 的使用变得更加简单。

## 小结

Promise 的优点在于，让回调函数变成了规范的链式写法，程序流程可以看得很清楚。它有一整套接口，可以实现许多强大的功能，比如同时执行多个异步操作，等到它们的状态都改变以后，再执行一个回调函数；再比如，为多个回调函数中抛出的错误，统一指定处理方法等等。

而且，Promise 还有一个传统写法没有的好处：它的状态一旦改变，无论何时查询，都能得到这个状态。这意味着，无论何时为 Promise 实例添加回调函数，该函数都能正确执行。所以，你不用担心是否错过了某个事件或信号。如果是传统写法，通过监听事件来执行回调函数，一旦错过了事件，再添加回调函数是不会执行的。

Promise 的缺点是，编写的难度比传统写法高，而且阅读代码也不是一眼可以看懂。你只会看到一堆`then`，必须自己在`then`的回调函数里面理清逻辑。




今天我想谈谈简单类型与复杂类型、原型链的一些体会

## 1 简单类型与复杂类型
我们知道在JavaScript中声明变量有几种方式，拿数值来做例子
```JavaScript
var n1 = 1;
var n2 = new Number(1);
```
那么这两种声明方式有什么区别呢？首先来打印这两个变量来看看<br>
![](https://i.loli.net/2018/05/13/5af832050e021.png)<br>
从图中可以看到`n1`就只有一个数值，而`n2`除了有一个私有值`1`之外，还有一个`__proto__`，里面放了很多东西。内存图如下<br>
![](https://i.loli.net/2018/05/13/5af8332ee27ae.png)<br>
从图中我们可以看到`n1`是直接存放在栈内存中的一个值，而`n2`其实是存放在堆内存中，栈内存中只存放了一个地址，指向堆内存<br>
那既然有这些差别，那我们为什么在实际的使用过程中没有感觉呢？`n2`所有的函数等等，用`n1`也全部都可以使用，看起来好像和内存图表示的不一样啊？
```JavaScript
n1.toString(); // "1"
```
`n1`看起来好像只有一个数值，并没有那些函数，为什么可以调用呢？其实这是由于JavaScript的独特设计造成的<br>
当执行上面那段代码的时候，其实JavaScript重新声明一个临时对象`temp`，利用`new Number()`的方式为`temp`赋值为`1`，那么`temp`就和`n2`的存储方式一样的了，再将`temp.toString()`的值赋给`n1.toString()`，然后清除`temp`，好像`temp`从未存在过，而`n1`也拥有了看似只有`n2`才有的属性<br>
<br>
接着执行下面的语句会发生什么？
```JavaScript
n1.name = 'yyzcl';
n1.name // ?
```
![](https://i.loli.net/2018/05/13/5af83650e9ae8.png)<br>
从图中看明明`n1.name`赋值成功了，调用的时候怎么就没有呢？<br>
其中的过程看可以看看内存图<br>
![](https://i.loli.net/2018/05/13/5af837b081d1d.png)<br>
这是`n1.name = 'yyzcl';`执行时的场景，JavaScript声明了一个临时对象来存放`n1.name`的值，所以并未报错。而当它执行`n1.name`时，由于临时对象在赋值语句之后随即被清除了，`n1`实际上还是只存在于栈内存中。<br>
当要搜寻`n1.name`的值时，再创建一个临时对象，在临时对象中去搜索`.name`这个值，由于新建的临时对象并没有`.name`这个值，所以会返回`undefined`<br>
![](https://i.loli.net/2018/05/13/5af839fda4291.png)<br>
<br>
## 2 原型与原型链
从上面我们可以知道，当利用
```JavaScript
var n1 = new Number();
var n2 = new Number();
……
```
这类语法声明多个变量时，如果要在堆内存中为每个变量开辟一个空间，单独存放每个变量的属性，那么就太浪费内存空间了。JavaScript就设计了一个特性，在内存中开辟一个空间存放变量共同的属性，然后每个变量独特的属性分开开辟空间存放，并存放一个地址，指向相同存放变量共同属性的地址。<br>
![](https://i.loli.net/2018/05/13/5af83ddf83d95.png)<br>
这里就涉及到原型链了，以`数值`、`字符串`、`对象`为例来看，声明一个变量，首先这个变量的私有属性有一个空间，然后还指向变量所属数据类型的一个共有属性空间，这个共有属性空间还指向`Object`的共有属性空间，具体关系如图所示<br>
![](https://i.loli.net/2018/05/13/5af8459f86e53.png)<br>
每个类型的共有属性会存放到一起，并用一个地址指向它，这样既可以节省空间，还不影响使用。<br>
<br>
>数值共有属性就是数值的原型，对象共同属性就是对象的原型
<br>
其实每个原型还有一个`constructor`属性，它指向引用它的上一级原型，例如：数值原型的`constructor`就指向具体的数值变量<br>
<br>
总结一下，由相互关联的原型组成的链状结构就是原型链<br>
<br>

## 3 \_\_proto\_\_与prototype
首先扔一张图
![](https://i.loli.net/2018/05/13/5af845e49ca14.png)<br>
给一个公式<br>

>var 对象 = new 函数()<br>
>对象.\_\_proto\_\_ === 函数.prototype<br>
<br>
函数.prototype也可以看做一个对象，于是就有了

>对象.\_\_proto\_\_.\_\_proto\_\_ === 函数.prototype.\_\_proto\_\_ === 函数.prototype.prototype
<br>
一直可以追寻到<br>
`Object.prototype`就结束了，因为`Object.prototype.__proto__`的值为`null`
<br>
<br>
如果有错误或者不严谨的地方，欢迎给予指正，十分感谢






